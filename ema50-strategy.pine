//@version=5
strategy("EMA50 Pullback Breakout (adjusted TP)", 
     overlay=true, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.01,
     calc_on_every_tick=true, process_orders_on_close=true, pyramiding=0)

// ===================== Inputs =====================
emaLen            = input.int(50,  "EMA Length")
atrPeriod         = input.int(22,  "ATR Period (Chandelier)")
atrMult           = input.float(3, "ATR Multiplier (Chandelier)", step=0.1)
rr                = input.float(1.5, "Risk:Reward TP (default 1.5)", step=0.1)  // Reduced default RR
maxBreakoutATRmul = input.float(3, "Max breakout body (× ATR)", minval=0.5, step=0.5)
showSwingLine     = input.bool(true, "Show swing line")
showMarkers       = input.bool(true, "Show debug markers")
sessionOnly       = input.bool(false, "Trade Only 08:00–20:00 UTC")
dynamicRR         = input.bool(true, "Enable Dynamic Risk:Reward Adjustment")  // New input for dynamic RR

// ===================== Indicators =====================
ema50 = ta.ema(close, emaLen)
atr   = ta.atr(atrPeriod)
longStop  = ta.highest(high, atrPeriod) - atrMult * atr
shortStop = ta.lowest(low,  atrPeriod) + atrMult * atr

hr        = hour(time, "UTC")
inSession = not sessionOnly or (hr >= 8 and hr < 20)

bodySize() => math.abs(close - open)
isRed()    => close < open
isGreen()  => close > open

// ===================== Dynamic Risk:Reward Adjustment =====================
adjustedRR = dynamicRR ? (atr > ta.sma(atr, atrPeriod) ? rr * 0.8 : rr) : rr  // Reduce RR by 20% if ATR is high

// ===================== State =====================
var bool  setupActive = false
var int   dir         = 0            //  1 = long setup, -1 = short setup
var float swingLevel  = na
var int   barsSinceBreak = 1000000
var line  swingLine   = na
var bool  pullbackReady = false

// For exit alerts, remember the SL/TP used at entry
var float lastSLLong   = na
var float lastTPLong   = na
var float lastSLShort  = na
var float lastTPShort  = na
var string lastSide    = ""  // "Long" / "Short" for context

// ===================== Signals (series) =====================
// Breakout detection
longBreak      = close[1] < ema50[1] and close > ema50 and isGreen()
shortBreak     = close[1] > ema50[1] and close < ema50 and isRed()
breakBodyOK    = bodySize() <= maxBreakoutATRmul * atr
oversizedBreak = (longBreak or shortBreak) and not breakBodyOK

// Count bars since most recent breakout
barsSinceBreak := ta.barssince(longBreak or shortBreak)

// Start a setup when breakout is valid
if (longBreak or shortBreak) and breakBodyOK and inSession
    setupActive := true
    dir         := longBreak ? 1 : -1
    swingLevel  := na
    pullbackReady := false

// Invalidation if pullback crosses back through EMA
if setupActive and ((dir == 1 and close < ema50) or (dir == -1 and close > ema50))
    setupActive   := false
    pullbackReady := false
    if showMarkers
        label.new(bar_index, dir==1?low:high, "Invalidated\nEMA recross", style=label.style_label_left, color=color.new(color.red, 0), textcolor=color.white)

// Pullback readiness (two opposite candles)
twoRedsAfterBreak   = setupActive and dir == 1 and isRed() and isRed()[1]
twoGreensAfterBreak = setupActive and dir == -1 and isGreen() and isGreen()[1]

if setupActive and dir == 1 and twoRedsAfterBreak
    swingLookback = math.max(2, math.min(20, barsSinceBreak + 2))
    swingLevel := ta.highest(high, swingLookback)
    pullbackReady := true

if setupActive and dir == -1 and twoGreensAfterBreak
    swingLookback = math.max(2, math.min(20, barsSinceBreak + 2))
    swingLevel := ta.lowest(low, swingLookback)
    pullbackReady := true

// Swing line
if showSwingLine
    if na(swingLine) or barstate.isfirst
        swingLine := line.new(bar_index, swingLevel, bar_index+1, swingLevel, extend=extend.right, color=color.new(color.blue, 0), width=2)
    else
        line.set_xy1(swingLine, bar_index, swingLevel)
        line.set_xy2(swingLine, bar_index+1, swingLevel)
        line.set_color(swingLine, na(swingLevel) ? color.new(color.blue, 100) : color.new(color.blue, 0))

// Entry triggers
longEntry  = setupActive and pullbackReady and dir == 1 and not na(swingLevel) and close > swingLevel and inSession
shortEntry = setupActive and pullbackReady and dir == -1 and not na(swingLevel) and close < swingLevel and inSession

// Compute SL/TP that would be used if an entry fires on this bar
slLongCalc  = longStop
tpLongCalc  = close + (close - slLongCalc) * adjustedRR  // Use adjusted RR
slShortCalc = shortStop
tpShortCalc = close - (slShortCalc - close) * adjustedRR  // Use adjusted RR

// ===================== Orders + ENTRY alerts =====================
if longEntry
    strategy.entry("Long", strategy.long)
    strategy.exit("TP/SL Long", from_entry="Long", stop=slLongCalc, limit=tpLongCalc)
    // remember for exit alert
    lastSLLong := slLongCalc
    lastTPLong := tpLongCalc
    lastSide   := "Long"
    // dynamic alert
    alert("LONG entry | TP: " + str.tostring(tpLongCalc, format.mintick) +
          " | SL: " + str.tostring(slLongCalc, format.mintick) +
          " | " + syminfo.ticker + " " + timeframe.period, alert.freq_once_per_bar_close)
    // visuals
    if showMarkers
        label.new(bar_index, low, "BUY\nSL: " + str.tostring(slLongCalc, format.mintick) + "\nTP: " + str.tostring(tpLongCalc, format.mintick),
                  style=label.style_label_up, color=color.new(color.teal,0), textcolor=color.white)
    // reset setup
    setupActive   := false
    pullbackReady := false
    swingLevel    := na

if shortEntry
    strategy.entry("Short", strategy.short)
    strategy.exit("TP/SL Short", from_entry="Short", stop=slShortCalc, limit=tpShortCalc)
    lastSLShort := slShortCalc
    lastTPShort := tpShortCalc
    lastSide    := "Short"
    alert("SHORT entry | TP: " + str.tostring(tpShortCalc, format.mintick) +
          " | SL: " + str.tostring(slShortCalc, format.mintick) +
          " | " + syminfo.ticker + " " + timeframe.period, alert.freq_once_per_bar_close)
    if showMarkers
        label.new(bar_index, high, "SELL\nSL: " + str.tostring(slShortCalc, format.mintick) + "\nTP: " + str.tostring(tpShortCalc, format.mintick),
                  style=label.style_label_down, color=color.new(color.orange,0), textcolor=color.white)
    setupActive   := false
    pullbackReady := false
    swingLevel    := na

// ===================== Exit detection + EXIT alerts =====================
// detect position close this bar
longClosed  = strategy.position_size[1] > 0  and strategy.position_size == 0
shortClosed = strategy.position_size[1] < 0  and strategy.position_size == 0

// Heuristic which target was hit (intrabar order of touches is unknown to strategies)
longTPHit  = longClosed  and not na(lastTPLong)  and high >= lastTPLong  and (low > lastSLLong or na(lastSLLong))
longSLHit  = longClosed  and not na(lastSLLong)  and low  <= lastSLLong
shortTPHit = shortClosed and not na(lastTPShort) and low  <= lastTPShort and (high < lastSLShort or na(lastSLShort))
shortSLHit = shortClosed and not na(lastSLShort) and high >= lastSLShort

if longTPHit
    alert("EXIT LONG | TP hit at " + str.tostring(lastTPLong, format.mintick) +
          " | " + syminfo.ticker + " " + timeframe.period, alert.freq_once_per_bar_close)
else if longSLHit
    alert("EXIT LONG | SL hit at " + str.tostring(lastSLLong, format.mintick) +
          " | " + syminfo.ticker + " " + timeframe.period, alert.freq_once_per_bar_close)

if shortTPHit
    alert("EXIT SHORT | TP hit at " + str.tostring(lastTPShort, format.mintick) +
          " | " + syminfo.ticker + " " + timeframe.period, alert.freq_once_per_bar_close)
else if shortSLHit
    alert("EXIT SHORT | SL hit at " + str.tostring(lastSLShort, format.mintick) +
          " | " + syminfo.ticker + " " + timeframe.period, alert.freq_once_per_bar_close)

// ===================== Global plots/markers =====================
plot(ema50, "EMA 50", color=color.new(color.orange, 0), linewidth=2)
plot(longStop,  "Chandelier Long",  color=color.new(color.red,   70), style=plot.style_linebr, display=display.none)
plot(shortStop, "Chandelier Short", color=color.new(color.red,   70), style=plot.style_linebr, display=display.none)
plotshape(showMarkers and longBreak  and breakBodyOK,  title="Break ↑", style=shape.triangleup,   location=location.belowbar, color=color.new(color.teal, 0), size=size.tiny, text="Break")
plotshape(showMarkers and shortBreak and breakBodyOK,  title="Break ↓", style=shape.triangledown, location=location.abovebar, color=color.new(color.orange,0), size=size.tiny, text="Break")
plotshape(showMarkers and oversizedBreak, title="Oversized", style=shape.diamond, location=location.top, color=color.new(color.red, 0), size=size.tiny, text="BIG")
plotshape(showMarkers and twoRedsAfterBreak,   title="2 red",   style=shape.circle, location=location.belowbar, color=color.new(color.red, 0), size=size.tiny, text="2R")
plotshape(showMarkers and twoGreensAfterBreak, title="2 green", style=shape.circle, location=location.abovebar, color=color.new(color.lime,0), size=size.tiny, text="2G")

// Optional static alertconditions (for those who prefer condition alerts over 'Any alert()')
// (Messages here are static; the dynamic prices above are sent via alert() calls.)
// alertcondition(longEntry,  "EMA50 Long (static)",  "EMA50 LONG signal")
// alertcondition(shortEntry, "EMA50 Short (static)", "EMA50 SHORT signal")